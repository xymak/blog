<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>mak&#39;s blog </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/blog/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
      <link href="/blog/index.xml" rel="alternate" type="application/rss+xml" title="mak&#39;s blog" />
      <link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="mak&#39;s blog" />
      
    
    
    <meta property="og:title" content="mak&#39;s blog" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xymak.github.io/blog/" />
<meta property="og:updated_time" content="2020-05-28T16:14:54+08:00" />
<meta itemprop="name" content="mak&#39;s blog">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="mak&#39;s blog"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://xymak.github.io/blog" class="f3 fw2 hover-white no-underline white-90 dib">
      mak&#39;s blog
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          mak&#39;s blog
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray">
    
  </article>
  
  
  
  
  
  
  
    
    

    <div class="pa3 pa4-ns w-100 w-70-ns center">
      
       
          <h1 class="flex-none">
            Recent Posts
          </h1>
        

      

      <section class="w-100 mw8">
        
        
          <div class="relative w-100 mb4">
            
<article class="bb b--black-10">
  <div class="db pv4 ph3 ph0-l no-underline dark-gray">
    <div class="flex flex-column flex-row-ns">
      
      <div class="blah w-100">
        <h1 class="f3 fw1 athelas mt0 lh-title">
          <a href="https://xymak.github.io/blog/posts/golang-channel/" class="color-inherit dim link">
            《Go 语言设计与实现》读书笔记：Channel
            </a>
        </h1>
        <div class="f6 f5-l lh-copy nested-copy-line-height nested-links">
          今天看了《Go 语言设计与实现》Channel相关的介绍。当初有遇到相关的问题，答得不是很好，这里记录一下。 其实golang channel的设计还是很简单的，结构体如下：
type hchan struct { qcount uint dataqsiz uint buf unsafe.Pointer elemsize uint16 closed uint32 elemtype *_type sendx uint recvx uint recvq waitq sendq waitq lock mutex }  qcount为当前元素个数 dataqsiz为总容量 buf为缓冲区数据指针 sendx为发送的标记位置 recvx为接收的标记位置 sendq为缓冲区不足的情况下阻塞的goroutine队列 recvq为不存在数据的情况下阻塞的goroutine队列  大体流程是这样的：
 发送情况：  如果是缓冲区空间不足或者不存在缓冲区，这里有两种情况：  有goroutine在接收队列等待，会直接将数据拷贝到接收goroutine的变量里面，sendq出队，并且唤醒接收goroutine 没有等待的goroutine，则通过gopark将当前goroutine设置为wait，并且初始化一个sudog入队recvq   如果缓存区空间充足：  有goroutine在接收队列等待，会直接将数据拷贝到接收goroutine的变量里面，sendq出队，并且唤醒接收goroutine 没有等待的goroutine，则写入buf     接收情况： 跟发送类似，镜像操作，这里不做多余陈述  另外，从底层也能发现，channel里面只有一个锁，接收和发送都要通过这一个锁做并发控制，所以用channel替代一些无锁的写法，性能是很差的。
        </div>
          <a href="https://xymak.github.io/blog/posts/golang-channel/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
        
      </div>
    </div>
  </div>
</article>

          </div>
        
          <div class="relative w-100 mb4">
            
<article class="bb b--black-10">
  <div class="db pv4 ph3 ph0-l no-underline dark-gray">
    <div class="flex flex-column flex-row-ns">
      
      <div class="blah w-100">
        <h1 class="f3 fw1 athelas mt0 lh-title">
          <a href="https://xymak.github.io/blog/posts/golang-single-flight/" class="color-inherit dim link">
            《Go 语言设计与实现》读书笔记：SingleFlight
            </a>
        </h1>
        <div class="f6 f5-l lh-copy nested-copy-line-height nested-links">
          今天读《Go 语言设计与实现》看到了一个感觉比较有用的golang同步原语，它能在一个服务中抑制多次重复的请求。
&ldquo;一个常用的场景是 - 我们使用redis对数据库中的数据进行缓存，发生缓存击穿，大量流量都会达到数据上进而影响服务的延时&rdquo;，这句话是作者的原话。从这句话我可以延伸到，还可以用来做合并请求，例如cdn上的合并请求。 之前我还因为缓存击穿扛过一个事故，就是mysql请求一直超时，redis缓存一直打不上，造成了恶性循环，所以我觉得这个同步原语非常有用。
它的结构体 x/sync/singleflight.Group 由一个映射表和一个互斥锁组成：
type Group struct { mu sync.Mutex m map[string]*call } type call struct { wg sync.WaitGroup val interface{} err error dups int chans []chan&lt;- Result } 它对外提供了两个用于抑制请求的方法：
 x/sync/singleflight.Group.Do — 同步等待的方法 Do； x/sync/singleflight.Group.DoChan — 返回 Channel 异步等待的方法；  func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) { g.mu.Lock() if g.m == nil { g.m = make(map[string]*call) } if c, ok := g.
        </div>
          <a href="https://xymak.github.io/blog/posts/golang-single-flight/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
        
      </div>
    </div>
  </div>
</article>

          </div>
        
          <div class="relative w-100 mb4">
            
<article class="bb b--black-10">
  <div class="db pv4 ph3 ph0-l no-underline dark-gray">
    <div class="flex flex-column flex-row-ns">
      
      <div class="blah w-100">
        <h1 class="f3 fw1 athelas mt0 lh-title">
          <a href="https://xymak.github.io/blog/posts/golang-mutex/" class="color-inherit dim link">
            《Go 语言设计与实现》读书笔记：互斥锁
            </a>
        </h1>
        <div class="f6 f5-l lh-copy nested-copy-line-height nested-links">
          最近在读《Go 语言设计与实现》的时候，里面提到golang里的互斥锁分正常模式和饥饿模式，饥饿模式是golang 1.9版本引入的优化。饥饿这个次有点抽象，我调研了一下为什么做了这方面的优化。 下面引入一下YiXu Zhang 写的文章
文章里的例子：
func main() { done := make(chan bool, 1) var mu sync.Mutex // goroutine 1  go func() { for { select { case &lt;-done: return default: mu.Lock() time.Sleep(100 * time.Microsecond) mu.Unlock() } } }() // goroutine 2  for i := 0; i &lt; 10; i++ { time.Sleep(100 * time.Microsecond) mu.Lock() mu.Unlock() } done &lt;- true } 如果用golang 1.8运行上面这个例子:
Lock acquired per goroutine: g1: 7200216 g2: 10 互斥锁被第二个协程捕获十次，而第一个协程则捕获了700万次。首先协程1获得锁后睡眠100ms，当协程2尝试获取锁时，它将被添加到锁的队列（FIFO）中，并且进入等待状态。 然后，协程1释放了锁。协程2也被唤醒了，被标记为可运行，然后等待调度器在线程上运行。 但是这个时候协程1又去获得锁。 到协程2去获得锁的时候，发现锁已经被其他线程持有了。 这个问题可以总结为：刚被唤起的协程与在运行的协程竞争时，大概率会获取不到锁。 本身golang 1.
        </div>
          <a href="https://xymak.github.io/blog/posts/golang-mutex/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
        
      </div>
    </div>
  </div>
</article>

          </div>
        
      </section>

      
      <section class="w-100">
        <h1 class="f3">More</h1>
        
        
          <h2 class="f5 fw4 mb4 dib mr3">
            <a href="https://xymak.github.io/blog/posts/nginx-core-dump-gdb/" class="link black dim">
              利用gdb分析nginx core dump文件
            </a>
          </h2>
        
          <h2 class="f5 fw4 mb4 dib mr3">
            <a href="https://xymak.github.io/blog/posts/etcd/" class="link black dim">
              今年晋升答辩的时候遇到的问题：etcd怎么添加新节点？
            </a>
          </h2>
        

        
        
          <a href="https://xymak.github.io/blog/posts/" class="link db f6 pa2 br3 bg-mid-gray white dim w4 tc">All Posts</a>
        
        </section>
      

      </div>
  

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xymak.github.io/blog" >
    &copy;  mak's blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/blog/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
